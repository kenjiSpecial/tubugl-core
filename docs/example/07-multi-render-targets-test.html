<html>
   <meta charset="UTF-8">
   <link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet">
   <style>
       *{
           margin: 0;
       }
       html, body{
        font-family: 'Roboto', sans-serif;
           width: 100%;
           height: 100%;
           overflow: hidden;
           background: #000000;
       }
       canvas{
           display: block;
       }
       #tubugl-desc{
           position: absolute;
           bottom: 20px;
           left: 20px;
           color: #aaaaaa;
           font-size: 12px;
           line-height: 1.5em;
       }
       
       #tubugl-loading{
           font-size: 14px;
           color: #ffffff;
           position: absolute;
           top:20px;
           left: 20px;
       }
       
       #tubugl-loading-initializing{
           display: none;
       }
       
       a{
            color: white;
       }
       a:hover{
           text-decoration: none;
       }
   </style>
   <script id="geo-vs" type="x-vertex-shader">
        #version 300 es
        layout(std140, column_major) uniform;
        layout(location=0) in vec4 aPosition;
        layout(location=1) in vec3 aNormal;
        layout(location=2) in vec4 aUV;
        uniform Matrices {
            mat4 uModelMatrix;
            mat4 uMVP;
        };
        
        out vec4 vPosition;
        out vec4 vNormal;
        out vec4 vUV;
        
        void main() {
            vPosition = uModelMatrix * aPosition;
            vNormal = uModelMatrix * vec4(aNormal, 0.0);
            vUV = aUV;
            gl_Position = uMVP * aPosition;
        }
    </script>
    <script id="geo-fs" type="x-fragment-shader">
        #version 300 es
        precision highp float;
        
        in vec4 vPosition;
        in vec4 vNormal; 
        in vec4 vUV;
        layout(location=0) out vec4 fragPosition;
        layout(location=1) out vec4 fragNormal;
        layout(location=2) out vec4 fragUV; 
        void main() {
            fragPosition = vPosition;
            fragNormal = vec4(normalize(vNormal.xyz), 1.0);
            fragUV = vUV;
        }
    </script> 
    <script id="main-vs" type="x-vertex-shader">
        #version 300 es
        
        layout(location=0) in vec4 position;
        
        uniform mat4 uMVP;
        
        out vec2 vUv;
        
        void main() {
            gl_Position =    position;
            vUv = vec2((position.x + 1.0)/2., (-position.y + 1.0)/2.);
        }
    </script>

    <script id="main-fs" type="x-fragment-shader">
        #version 300 es
        precision highp float;
        
        in vec2 vUv;
        
        out vec4 fragColor;
        
        uniform sampler2D uTexture;
        
        void main(){
            vec4 col = texture(uTexture, vUv);
            fragColor = col;
        }
    </script>
    
   <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0"/>
   <script src="./vendor/gl-matrix-min.js"></script>
   <script src="./vendor/tubu-generate-geometry.js"></script>
   <script src="./vendor/tubu2.js"></script>
<body>
    <div id="tubugl-desc">
        <p class="tubugl-p">#07 - MultiRenderTarget implement test</p>
        <p class="tubugl-p">Developed with <a href="https://github.com/kenjiSpecial/tubugl">tubugl</a></p>
        <p class="tubugl-p">See <a href="./index.html">other examples</a></p>
    </div>
    
    <canvas id="gl-canvas"></canvas>
    
    <script>
        var canvas, gl;
        var obj, vao, arrayBuffer, program, numCubeVertices;
        var cubeVertexArray, planeVertexArray;
        var uniformBlockObj = {};
        var loopId;
        var textureLocation;
        var urlParams = new URLSearchParams(window.location.search);
        var isDebug = !(urlParams.has('NoDebug') || urlParams.has('NoDebug/'));
        var multiRenderTarget;
        var viewProjMatrix, boxes, matrixUniformData, matrixUniformBuffer;
        
        var translateMat = mat4.create();
        var rotateXMat = mat4.create();
        var rotateYMat = mat4.create();
        var rotateZMat = mat4.create();
        var scaleMat = mat4.create();
        
        initializeGl();
        createMultiRenderTarget();
        createProgram();
        createGeometry();
        
        if(isDebug) requestAnimationFrame(loop);
        else loop();
        
        
        // initialize the webgl context
        function initializeGl(){
            canvas = document.getElementById('gl-canvas');
            gl = canvas.getContext('webgl2');
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            
            
            if(!isDebug){
                var desc = document.getElementById('tubugl-desc');
                desc.style.display = 'none';
            }
        }
        
        function createMultiRenderTarget(){
            multiRenderTarget = new Tubu.MultiRenderTarget(gl, document.getElementById('geo-vs').textContent.trim(), document.getElementById('geo-fs').textContent.trim());
            multiRenderTarget.bind();
            multiRenderTarget.createTexture('positionTarget', gl.RGBA16F);
            multiRenderTarget.createTexture('normalTarget', gl.RGBA16F);
            multiRenderTarget.createTexture('uvTarget', gl.RG16F);
            multiRenderTarget.createDepthTexture();
            multiRenderTarget.updateDrawBuffers();
            multiRenderTarget.unbind();
        }
        
        // create webgl program
        function createProgram(){
            program = new Tubu.Program2(
                gl,
                document.getElementById('main-vs').textContent.trim(), 
                document.getElementById('main-fs').textContent.trim()
            );
        }
        
        function createGeometry(){
            var  box = Tubu.createSimpleBox(1, 1, 1);

            cubeVertexArray = gl.createVertexArray();
            gl.bindVertexArray(cubeVertexArray);
            
            var positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, box.positions, gl.STATIC_DRAW);
            gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(0);
            var normalBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, box.normals, gl.STATIC_DRAW);
            gl.vertexAttribPointer(1, 3, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(1);
            var uvBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, uvBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, box.uvs, gl.STATIC_DRAW);
            gl.vertexAttribPointer(2, 2, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(2);
            
            numCubeVertices = box.positions.length / 3;
            
            // ==================================
            
            planeVertexArray = gl.createVertexArray();
            
            gl.bindVertexArray(planeVertexArray);
            var plainData = new Float32Array([
                -1, -1,
                1, -1,
                -1, 1,
                1, -1,
                -1, 1,
                1, 1,
            ]);
            var planePositionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, planePositionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, plainData, gl.STATIC_DRAW);
            gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(0);
            
            gl.bindVertexArray(null);
            
            var projMatrix = mat4.create();
            mat4.perspective(projMatrix, Math.PI / 2, canvas.width / canvas.height, 0.1, 1000.0);
            var viewMatrix = mat4.create();
            var eyePosition = vec3.fromValues(1, 1, 1);
            mat4.lookAt(viewMatrix, eyePosition, vec3.fromValues(0, 0, 0), vec3.fromValues(0, 1, 0));
            viewProjMatrix = mat4.create();
            mat4.multiply(viewProjMatrix, projMatrix, viewMatrix); // projectM * viewMatrix 
            
            // ------------
            
            boxes = [
                {
                    scale: [1, 1, 1],
                    rotate: [0, 0, 0],
                    translate: [0, 0, 0],
                    modelMatrix: mat4.create(),
                    mvpMatrix: mat4.create(),
                },
                {
                    scale: [0.1, 0.1, 0.1],
                    rotate: [0, 0, Math.PI / 3],
                    translate: [0.8, 0.8, 0.4],
                    modelMatrix: mat4.create(),
                    mvpMatrix: mat4.create(),
                }
            ];
            
            matrixUniformData = new Float32Array(32);
            matrixUniformBuffer = gl.createBuffer();
            gl.bindBufferBase(gl.UNIFORM_BUFFER, 0, matrixUniformBuffer);
            gl.bufferData(gl.UNIFORM_BUFFER, 128, gl.DYNAMIC_DRAW);
        }
        
        function xformMatrix(xform, translate, rotate, scale) {
            translate = translate || zeros;
            rotate = rotate || zeros;
            scale = scale || ones;

            mat4.fromTranslation(translateMat, translate);
            mat4.fromXRotation(rotateXMat, rotate[0]);
            mat4.fromYRotation(rotateYMat, rotate[1]);
            mat4.fromZRotation(rotateZMat, rotate[2]);
            mat4.fromScaling(scaleMat, scale);

            mat4.multiply(xform, rotateXMat, scaleMat);
            mat4.multiply(xform, rotateYMat, xform);
            mat4.multiply(xform, rotateZMat, xform);
            mat4.multiply(xform, translateMat, xform);
        }
        
        function loop(){
            multiRenderTarget.bind();
            multiRenderTarget.useProgram();
            
            gl.bindVertexArray(cubeVertexArray);
            gl.depthMask(true);
            gl.enable(gl.DEPTH_TEST);
            gl.disable(gl.BLEND);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            
            var width = gl.canvas.width;
            var height = gl.canvas.height;
            gl.viewport(0, 0, width, height);
            for (var i = 0, len = boxes.length; i < len; ++i) {
                boxes[i].rotate[0] += 0.01;
                boxes[i].rotate[1] += 0.02;
                xformMatrix(boxes[i].modelMatrix, boxes[i].translate, boxes[i].rotate, boxes[i].scale);
                mat4.multiply(boxes[i].mvpMatrix, viewProjMatrix, boxes[i].modelMatrix);
            
                matrixUniformData.set(boxes[i].modelMatrix);
                matrixUniformData.set(boxes[i].mvpMatrix, 16);
                gl.bindBufferBase(gl.UNIFORM_BUFFER, 0, matrixUniformBuffer);
                gl.bufferSubData(gl.UNIFORM_BUFFER, 0, matrixUniformData);
                gl.drawArrays(gl.TRIANGLES, 0, numCubeVertices);
            }
            
            multiRenderTarget.unbind();
            program.use();
            
            for(var ii = 0; ii < 3; ii++){
                
                var width = gl.canvas.width/2;
                var height = gl.canvas.height/2;
                var xx = width * parseInt(ii/2);
                var yy = height * parseInt(ii%2);
                gl.viewport(xx, yy, width, height);
                
                gl.bindVertexArray(planeVertexArray);
                gl.depthMask(false);
                gl.enable(gl.DEPTH_TEST);
                gl.enable(gl.BLEND);
                
                let index = 0;
                var texture;
                switch(ii){
                    case 0:
                    texture  = multiRenderTarget.target['positionTarget'];
                    break;
                    case 1:
                    texture  = multiRenderTarget.target['normalTarget'];
                    break;
                    case 2:
                    texture  = multiRenderTarget.target['uvTarget'];
                    break;
                }
                
                gl.activeTexture(gl.TEXTURE0 + index);
                gl.bindTexture(gl.TEXTURE_2D, texture);
                gl.uniform1i(textureLocation, index);	
            
                gl.drawArrays(gl.TRIANGLES, 0, 6); 
            }
            
            if(isDebug) requestAnimationFrame(loop);
        }
        
        function resizeHandler(){
            resize();
        }
        
        function resize(){
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
        }
        
        window.addEventListener('resize', resizeHandler);
    </script>
</body>
</html>